
---
layout: post
title: '数据库事务的隔离级别'
subtitle: '数据库事务的隔离级别'
date: 2018-03-30
categories: 技术
cover: ''
tags: 数据库事务
---

# 数据库事务的隔离级别

* 作者: 宇永

* 时间: 2018-03-30 10:32

---

## 事务使用过程中会出现的问题

因为数据库事务的特性,在多线程的环境下使用数据库事务会出现以下三种情况:

* 脏读

  脏读是指在一个事务处理过程里读取到了另一个未提交的事务中的数据.
  
* 不可重复读
  
  不可重复读是指在对于数据库中的某个数据,一个事务范围内多次查询却返回了不一样的数据.这是由于多条查询语句之间存在间隔,在间隔时间内,其他事务修改了数据并提交了.
  
  **强调的是同一事务中两次查询先后不一致.**

* 幻读

  幻读和不可重复读都是读取了另一条已经提交的事务,所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体. 例如A事务里面第一次查询出数据一共有10条,第二次查询之前有数据新插入进来,结果查询后为11条.此时就出现了幻读.
  
  **强调的是同一事务中查询结果都是第一次查询时的状态.**
  
  但是,如果另一个事务同时提交了新数据,虽然本事务再次按照相同的条件查找会得到相同的结果集,但是本事务指定更新时,就会"惊奇的"发现了这些新数据，貌似之前读到的数据是"鬼影"一样的幻觉.例如查询出只有一条记录,于是根据这条记录的某个结果字段A进行更新.但是另外一个事务在此之前 `insert`了一条数据 字段与A字段相同.此时本事务中`update` 操作结果将是返回影响2条.

---

## 四种事务隔离机制

数据库提供了四种事务隔离级别, 不同的隔离级别采用不同的锁类开来实现.

* 不使用隔离机制:(非事务隔离机制)

  **存在的问题:更新遗失**
  
  当不同的事务同时更新一条数据,后面的数据覆盖前面的数据.

* 可读取未提交:(Read Uncommitted)

  写事务会阻止其他写事务,避免了**更新遗失**.但是没有阻止其他读事务.
  
  **存在的问题:脏读**
  
* 可读取已提交:(Read Committed)

  写事务会阻止其他读写事务.读事务不会阻止其他任何事务.
  
  **存在的问题:不重复读**
  
* 可重复读:(Repeatable Read)

  读事务会阻止其他写事务,但是不会阻止其他读事务.

  在同一个事务里,SELECT的结果是事务开始时时间点的状态,因此,同样的 `select` 操作读到的结果会是一致的.
  
  **存在的问题:幻读**

* 可串行化:(Serializable)

  读加共享锁,写加排他锁,这样读取事务可以并发,但是读写,写写事务之间都是互斥的,基本上就是一个个执行事务(事务一般不会单独加在读取操作上),所以叫串行化.
  
---

ps: 

1. `mysql` 数据库默认事务隔离级别属于 **可重复读**

2. `oracle` 数据库默认事务隔离级别属于 **可读取已提交**
  
    

